\chapter{Аналитическая часть}

\section{Анализ предметной области}

Все изображения можно разделить на две группы.
\begin{enumerate}
    \item \textbf{Статические изображения} --- это визуальные представления, не содержащие анимации или элементов взаимодействия. Они остаются неизменными и могут быть представлены в виде рисунков, фотографий, диаграмм или любых других неподвижных изображений сцен или объектов.
    \item \textbf{Динамические изображения} --- это визуальные представления, содержащие движения или изменения в течение времени. В отличие от статических, они могут быть анимированными, интерактивными (реагировать на клики или наведение) или включать переходы. Примеры: анимация, видео, GIF-файлы, интерактивная графика.
\end{enumerate}

Существуют два основных типа сжатия изображений --- с потерями и без потерь. Сжатие без потерь позволяет уменьшить размер файла с сохранением всех деталей исходного изображения. Сжатие с потерями приводит к более сильному уменьшению размера исходного файла ценой потери его деталей, следствием чего является потеря качества изображения.

Разработаны различные форматы файлов изображений, каждый из которых предназначен для определенных задач и использует в своей реализации собственные способы сжатия и сохранения информации. Например, формат JPEG используется для сжатия с потерями, тогда как формат PNG предназначен для сжатия изображений без потерь.

Уменьшить размер сжатого файла можно путем изменения параметров сжатия, таких как качество изображения и его разрешение. 
Более высокие значения этих параметров приведут к увеличению размера полученнного файла.

Сокращение числа цветов в изображении также будет способствовать уменьшению размера сжатого файла, так как приведет к снижению числа байт, необходимых для представления каждого пикселя.


\section{Методы сжатия статических изображений без потерь}

\subsection{Метод RLE}

Метод RLE основан на идее кодирования последовательностей повторяющихся значений. Задача данного метода заключается в нахождении цепочек одинаковых символов и замене их на одно значение из последовательности и количество повторений. Такой алгоритм подходит для сжатия как текстовых файлов, так и изображений, где в роли каждого символа выступает набор байт, необходимый для хранения одного пикселя.

Например, если изображение содержит несколько подряд идущих пикселей одного цвета, то рассматриваемый метод закодирует данную последовательность в виде одного пикселя и количества его повторений. Из описания алгоритма можно сделать вывод о том, что он эффективен для изображений с большим количеством повторяющихся участков или частыми областями одного цвета. Однако RLE не подходит для изображений с большим количеством деталей, где, помимо низкой степени сжатия, может привести к увеличению размера файла.

Рассматриваемый метод относится к сжатию без потерь и может использоваться как отдельно, так и в комбинации с другими алгоритмами для достижения лучшего результата.

Процесс работы алгоритма можно описать следующим образом.
\begin{enumerate}
    \item Создать пустую строку для хранения результата.
    \item Произвести проход по всем пикселям изображения (по всем строкам слева направо).
    \item Для каждого пикселя.
    \begin{itemize}
        \item Если он совпадает с предыдущим, увеличить счётчик повторений.
        \item Если отличается или достигнут конец строки:
        \begin{itemize}
            \item В результирующую строку записать значение предыдущего пикселя и количество его повторений.
            \item Сбросить счётчик и начать отсчёт заново.
        \end{itemize}
    \end{itemize}
    \item После завершения прохода добавить данные о последнем пикселе и количестве его повторений.
    \item Вернуть строку с закодированными данными.
\end{enumerate}

Пример работы алгоритма:
\begin{itemize}
    \item входная строка: \texttt{FFFFCCBBBDAA};
    \item закодированные данные: \texttt{4F2C3B1D2A}.
\end{itemize}

\subsection{Словарные методы}

Словарные методы сжатия, например LZW (Lempel-Ziv-Welch), основаны на использовании специального словаря, в котором повторяющиеся последовательности заменяются более короткими кодами. Такой подход позволяет существенно сократить объём данных за счёт замены часто встречающихся шаблонов уникальными кодами из словаря.

Принцип работы алгоритма LZW заключается в том, что он анализирует входные данные и постепенно строит словарь, где каждой повторяющейся последовательности символов присваивается определённый код. После создания словаря эти коды используются для замены изначальных последовательностей, что и обеспечивает сжатие.

Изначально словарь содержит все возможные односимвольные последовательности. Алгоритм считывает входной поток слева направо, формируя текущую последовательность символов. Как только встречается цепочка значений, отсутствующая в словаре, она добавляется туда, а в выходной поток записывается код уже известной части. Этот процесс продолжается до тех пор, пока весь поток данных не будет обработан. При декодировании используется тот же самый словарь для восстановления исходной информации.

Пошаговый алгоритм метода LZW можно описать следующим образом.
\begin{enumerate}
    \item Создать словарь со всеми возможными односимвольными значениями (пикселями).
    \item Установить начальное значение последовательности W равным первому символу входных данных.
    \item Последовательно считывать символа K из входного потока.
    \begin{itemize}
        \item Проверить, содержится ли комбинация W + K в текущем словаре.
        \item Если да, то W := W + K, после чего продолжить анализ.
        \item Если нет.
        \begin{itemize}
            \item Добавить код для текущей последовательности W в результат.
            \item Добавить новую комбинацию W + K в словарь с уникальным кодом.
            \item Присвоить W значение K.
        \end{itemize}
    \end{itemize}
    \item Добавить код последней оставшейся в буфере последовательности W.
    \item Вернуть полученную рузультат в виде последовательности кодов.
\end{enumerate}

\subsection{Унарное кодирование}

Унарное кодирование представляет собой префиксный код, основанный на идее представления целых положительных чисел $n$ в виде последовательности из $(n - 1)$ битов со значением 1, и одного бита со значением 0, следующим за цепочкой единиц. Также возможно обратное представление, где в начале кода идет последовательность из $(n - 1)$ нулей, заканчивающаяся единицей.

Данный метод следует использовать только для представления очень малых чисел, в противном случае унарное кодирование может привести к увеличению размера исходного файла. Примером эффективного использования является сжатие изображений с малой цветовой политрой. Например, при сжатии черно-белой фотографии с малым количеством оттенков серового (с 8 оттенками для примера) самый часто встречающийся пиксель получит значение унарного кода \texttt{0} (соответствующее $n = 1$), а самый редко встречающийся будет представлен значением \texttt{11111110} (соответствующим $n = 8$).


% это метод статистического кодирования, который может использоваться в сжатии изображений для представления значений пикселей, особенно в случае, когда значения пикселей ограничены небольшим диапазоном. 

% Если есть изображение в оттенках серого, где значения пикселей находятся в диапазоне от 0 до 7 (0 соответствует самому частому оттенку серого, 7 --- самому редкому), то можно использовать унарное кодирование для представления этих значений.

% В данном алгоритме каждое значение представляется последовательностью единиц, за которой следует ноль. Количество единиц в последовательности определяет значение пикселя. Например, значение 3 будет представлено как 1110, где три единицы обозначают значение 3, а ноль обозначает конец кода. Значение 0 будет представлено как 0.

% Унарное кодирование может применяться для сжатия изображений, если значения пикселей имеют ограниченный диапазон и малую вариацию. В случае большого диапазона значений или большой вариации, унарное кодирование может привести к увеличению размера файла. В таких случаях следует использовать другие методы сжатия изображений.

\subsection{Метод Хаффмана}

Алгоритм Хаффмана --- метод сжатия данных, основанный на замене часто встречающихся символов более короткими кодами, а реже встречающихся --- более длинными. Данный алгоритм может использоваться для сжатия изображений без потерь, в этом случае пиксели выступают в роли кодируемых символов.

Для реализации метода Хаффмана необходимо знать вероятности вхождения символов в сообщение, которые будут использоваться для наделения весом каждого пикселя.

Алгоритм построения дерева Хаффмана.
\begin{enumerate}
    \item Строится список свободных узлов на основе символов входного алфавита. Для этого каждый лист наделяется весом, равным вероятности вхождений символа в ожидаемое сообщение.
    \item Из свободных узлов дерева выбираются 2 с наименьшими весами.
    \item Для выбранных узлов создается родитель с суммарным весом.
    \item Дуге к потомку с меньшим весом ставится в соответствие бит 1, с большим весом --- бит 0.
    \item Родитель заменяет в списке свободных узлов двое своих потомков.
    \item Пункты 2--5 повторяются до тех пор, пока в списке свободных узлов не останется только один узел, который станет корнем дерева.
\end{enumerate}

Построенное дерево будет использоваться для определения кодов символов (пикселей) из полученного сообщения (изображения).
Для этого необходимо пройти путь от листа дерева, соответствующего текущему символу, до корня, дописывая биты при каждом переходе по ветвям дерева. Таким образом, полученная последовательность битов будет соответствовать записанному в обратном порядке коду данного символа (пикселя).

Несмотря на то, что коды Хаффмана имеют переменную длину, они могут быть однозначно декодированы, так как обладают уникальными префиксами. 

Для восстановления исходного изображения декодер должен иметь доступ к таблице частот, которая использовалась при кодировании. Это означает, что длина сжатого сообщения увеличится на длину таблицы частот, которая должна быть передана перед данными. Также к недостатку рассматриваемого метода можно отнести необходимость повторного прохода по изображению: один для построения дерева Хаффмана, другой для кодирования.

\subsection{Арифметическое кодирование}

Арифметическое кодирование является блочным и имеет уникальный выходной код для каждого возможного входного сообщения. Нельзя разбить его на коды отдельных символов, в отличие от кодов Хаффмана, которые присваиваются отдельным буквам входного алфавита.

При использовании арифметического кодирования, слово можно представить в виде двоичной дроби из интервала от 0 до 1. С увеличением длины слова, этот интервал сокращается, требуя больше битов для его определения. 

Алгоритм арифметического кодирования нуждается в  распределении частот символов входного сообщения. Более вероятные символы добавляют меньше битов к общей длине закодированного слова, так как приводят к уменьшению интервала на меньшую величину, по сравнению с маловероятными символами. 

Арифметическое кодирование представляет каждый символ исходного текста с помощью числового интервала на оси, причем длина этого интервала соответствует вероятности появления символа. Начало интервала совпадает с концом интервала предыдущего символа в алфавите. Сумма всех интервалов равна единице. При поступлении нового символа, из текущего интервала <<вырезается>> подинтервал пропорционально длине и положению этого символа на оси.

Следует отметить, что арифметическое кодирование требует только одного прохода по данным для кодирования и декодирования, в отличие от алгоритма Хаффмана.

\subsection{Сравнение методов сжатия без потерь}

Сравнение предлагается проводить по следующим критериям.
\begin{enumerate}
    \item Возможность кодирования данных за один проход.
    \item Необходимость в таблице частот пикселей сжимаемого изображения.
    \item Наличие в зашифрованном сообщении информации для дешифровщика (распаковщика).
    \item Наличие у каждого сжатого пикселя своего кода.
\end{enumerate}

Результаты сравнения методов сжатия изображений без потерь приведены в таблице \ref{tbl:compare_realizations1}.
\begin{table}[H]
    \centering
	\caption{Сравнение рассмотренных методов сжатия изображений без потерь}
    \label{tbl:compare_realizations1}
	\begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Метод сжатия} & \textbf{Кр. 1} & \textbf{Кр. 2} & \textbf{Кр. 3} & \textbf{Кр. 4}
        \\ \hline
        Алгоритм RLE               & +  & -- & -- & -- \\ \hline
        Словарные алгоритмы        & +  & -- & +  & -- \\ \hline
        Унарное кодирование        & +  & +  & +  & +  \\ \hline
        Алгоритм Хаффмана          & -- & +  & +  & +  \\ \hline
        Арифметическое кодирование & +  & +  & +  & -- \\ \hline
    \end{tabular}
\end{table}

\section{Методы сжатия статических изображений с потерями}

\subsection{Метод сжатия JPEG}

JPEG (Joint Photographic Expert Group) --- алгоритм сжатия изображений с потерями, который является неофициальным стандартом для полноцветных изображений. Он использует области пикселей размером 8x8, в которых яркость и цвет изменяются плавно. Из-за этого, при разложении матрицы такой области в двойной ряд по косинусам, только первые коэффициенты оказываются значимыми. Это позволяет осуществлять сжатие за счет плавных изменений цвета в изображении.

Алгоритм JPEG можно описать следующим образом.
\begin{enumerate}
    \item \textbf{Разделение изображения на блоки.} Изображение разбивается на квадратные блоки пикселей размером 8x8 пикселей.
    \item \textbf{Преобразование цветовой модели.} Изначально изображение может быть представлено в различных цветовых моделях, таких как RGB. Алгоритм JPEG преобразует изображение из цветовой модели RGB в цветовую модель YCbCr, где Y представляет яркость, а Cb и Cr представляют различные цветовые компоненты.
    \item \textbf{Преобразование Фурье.} Применение двумерного дискретного преобразования Фурье (DCT) к каждому блоку пикселей 8x8. DCT преобразует блоки пикселей в блоки коэффициентов, представляющих частоты различных компонент изображения.
    \item \textbf{Квантование.} Коэффициенты DCT квантуются путем деления на заранее заданную таблицу квантования. Значениями таблицы квантования являются коэффициенты, определяющие степень потери информации.
    \item \textbf{Кодирование.} Коэффициенты квантования кодируются с использованием энтропийного кодирования, такого как алгоритм Хаффмана. Это сжатие используется для эффективного представления значений блоков пикселей в виде битовых последовательностей с переменной длиной.
    \item \textbf{Упаковка данных.} Кодированные данные объединяются и упаковываются в структуру, известную как JPEG-файл. Этот файл может быть сохранен или передан по сети.
    \item \textbf{Декодирование.} Для восстановления изображения из JPEG-файла процесс выполняется в обратном порядке. Данные распаковываются, декодируются с использованием алгоритма Хаффмана, применяется обратное квантование и обратное DCT преобразование. Затем изображение восстанавливается в цветовую модель RGB.
\end{enumerate}

В результате алгоритма JPEG получается сжатое изображение с потерями, где некоторая информация оригинального изображения теряется, но с сохранением достаточного качества для большинства приложений.

\subsection{Wavelet сжатие}

Вейвлеты --- это математические функции, которые используются для анализа частотных компонент данных. По сравнению с форматами сжатия, такими как JPEG и фрактальный алгоритм, вейвлеты выделяются тем, что не требуют предварительного разбиения исходного изображения на блоки, а могут быть применены к изображению в целом.

Для примера, возьмем одномерное преобразование Хаара. При нем каждой паре элементов сигнала сопоставляются два числа: полусумма элементов и их полуразность. Так как из них можно получить исходную пару чисел, то преобразование будет обратимым.

В результате сигнал разложится на две составляющие: приближенное значение исходного сигнала (разрешение которого уменьшится в два раза) и уточняющую информацию.

Двумерное преобразование Хаара представляет собой объединение одномерных преобразований. В случае, если исходные данные будут записаны в виде матрицы, сначала выполнятся преобразования для каждой строки, а затем для полученных матриц выполнятся преобразования для каждого столбца. Это позволит получить четыре матрицы. Одна из которых будет содержать аппроксимацию исходного изображения (частота дискретизации которой уменьшится), в то время как три другие матрицы будут содержать уточняющую информацию. 

Само сжатие достигается путем удаления некоторых коэффициентов из уточняющих матриц, что позволяет значительно уменьшить размер данных, сохраняя при этом важные детали изображения.

Данный метод был разработан специально для цветных и черно-белых изображений с плавными переходами, из-за чего подходит для обработки рентгеновских снимков и МРТ.

\subsection{Фрактальный метод}

Фрактальное сжатие изображений --- это метод сжатия данных, основанный на использовании фрактальных кодов. Алгоритм использует идею самоподобия в изображении, чтобы создать компактное представление оригинала.

Алгоритм фрактального сжатия можно описать следующим образом.
\begin{enumerate}
    \item \textbf{Деление изображения на блоки.} Изображение разбивается на небольшие блоки пикселей, называемые фракталами. Обычно используются группы размером 2x2, 4x4 или 8x8 пикселей. Это нужно, чтобы каждый блок мог быть рассмотрен как потенциально самоподобная часть изображения.
    \item \textbf{Выбор базисного фрактала.} Из множества фракталов выбирается один в качестве базисного блока. Он будет использоваться для аппроксимации других фракталов.
    \item \textbf{Поиск подходящих фракталов.} Для каждого блока изображения ищутся наиболее похожие фракталы из множества доступных блоков. Похожесть определяется с помощью различных метрик, таких как евклидово расстояние или среднеквадратичная ошибка.
    \item \textbf{Аппроксимация фракталов.} Найденные похожие блоки аппроксимируются с использованием базисного фрактала. Аппроксимация может быть выполнена с помощью различных методов, например, с использованием аффинных преобразований или кодирования Хаффмана.
    \item \textbf{Создание фрактального кода.} Для каждого блока сохраняется информация о выбранном базисном фрактале и преобразованиях, используемых для его аппроксимации. Эта информация составляет фрактальный код.
    \item \textbf{Восстановление изображения.} Фрактальный код декодируется, чтобы получить информацию о выбранных базисных фракталах и преобразованиях. Эта информация используется для восстановления исходных блоков и соединения их в изображение.
\end{enumerate}

Фрактальное сжатие обеспечивает высокую степень сжатия при сохранении деталей для изображений, содержащих много повторяющихся узоров, таких как текстуры или некоторые естественные изображения. Тем не менее, алгоритм сложен в реализации и может занимать много времени для сжатия и декомпрессии больших изображений.

\subsection{Сравнение методов сжатия с потерями}

Сравнение предлагается проводить по следующим критериям.
\begin{enumerate}
    \item Идея, на которой строится алгоритм сжатия.
    \item Тип артефактов, возникающих при больших коэффициентах сжатия.
    \item Необходимость разбиения исходного изображения на блоки.
    \item Необходимость преобразование изображения из цветовой модели RGB в цветовую модель YCbC.
\end{enumerate}

\clearpage

Результаты сравнения методов сжатия изображений без потерь приведены в таблице \ref{tbl:compare_realizations2}.
\begin{table}[H]
    \centering
	\caption{Сравнение рассмотренных методов сжатия изображений без потерь}
    \label{tbl:compare_realizations2}
	\begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Метод сжатия} & \textbf{Кр. 1} & \textbf{Кр. 2} & \textbf{Кр. 3} & \textbf{Кр. 4}
        \\ \hline
        JPEG        & \begin{minipage}[t]{5.5cm}\centering Дискретное косинусное \newline преобразование \end{minipage} & \begin{minipage}[t]{3.1cm}\centering Блочные \newline артефакты \newline \end{minipage} & + & + \\ \hline
        Wavelet     & Вейвлет-преобразование & \begin{minipage}[t]{3.1cm}\centering Кольцевые \newline артефакты \newline \end{minipage}     & -- & --  \\ \hline 
        Фрактальный & Самоподобие множеств   & \begin{minipage}[t]{3.1cm}\centering Артефакты \newline реконструкции \newline \end{minipage} & +  & -- \\ \hline
    \end{tabular}
\end{table}

\section{Цветовые модели изображений}

\subsection{Анализ цветовых моделей изображений}

Цветовые модели изображений --- это системы, которые описывают, как цвета представлены в цифровых изображениях. Они определяют способ кодирования и хранения цветовой информации, а также позволяют преобразовывать цвета между различными форматами и устройствами отображения.

\begin{enumerate}
    \item RGB (Red, Green, Blue) --- это аддитивная цветовая модель, основанная на смешении трех основных цветов: красного, зеленого и синего. Она широко используется в цифровых устройствах, таких как мониторы, телевизоры и камеры, где цвета создаются путем добавления света. Каждый цвет представлен значением интенсивности от 0 до 255, что позволяет получить более 16 миллионов оттенков. RGB является стандартом для экранного отображения.
    \item RGBA (Red, Green, Blue, Alpha) --- это расширение модели RGB, которое добавляет четвертый компонент --- альфа-канал. Альфа-канал определяет прозрачность цвета, где 0 означает полную прозрачность, а 255 --- полную непрозрачность. Эта модель используется в графике и анимации для создания эффектов наложения и прозрачности.
    \item CMYK (Cyan, Magenta, Yellow, Key/Black) --- это субтрактивная цветовая модель, используемая в полиграфии и печати. Она основана на вычитании света из белого фона с помощью чернил. CMYK работает с четырьмя цветами: голубым, пурпурным, желтым и черным. Эта модель оптимальна для печатных материалов, так как позволяет точно воспроизводить цвета на бумаге.
    \item LAB (Lightness, A, B) --- это цветовая модель, которая описывает цвет с точки зрения его яркости (Lightness) и двух цветовых компонентов: A и B. Компонент A представляет собой ось от зеленого до красного, а компонент B — ось от синего до желтого. 
    
    LAB является устройственно-независимой моделью, что делает её полезной для задач цветокоррекции и преобразования между различными цветовыми пространствами. Она основана на восприятии цвета человеческим глазом и охватывает большее количество цветов, чем RGB или CMYK. 
    
    LAB часто используется в графических редакторах и системах управления цветом для точной настройки цвета и обеспечения согласованности между устройствами отображения и печати.
    \item HSB (Hue, Saturation, Brightness) --- это цветовая модель, которая описывает цвет с точки зрения его оттенка (Hue), насыщенности (Saturation) и яркости (Brightness). Оттенок определяет основной цвет (например, красный или синий), насыщенность — интенсивность цвета, а яркость --- его светлоту. HSB удобна для работы с цветами в графических редакторах, так как позволяет интуитивно изменять их параметры.
\end{enumerate}

\subsection{Сравнение цветовых моделей изображений}

Сравнение предлагается проводить по следующим критериям.
\begin{enumerate}
    \item Класс метода по принципу действия.
    \item Количество байт для кодирования одного пикселя.
    \item Наличие поддержки альфа-канала.
    \item Наличие отдельного канала для яркости.
\end{enumerate}

Результаты сравнения цветовых моделей изображений приведены в таблице \ref{tbl:color_models}.
\begin{table}[H]
    \centering
	\caption{Сравнение рассмотренных цветовых моделей изображений}
    \label{tbl:color_models}
	\begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Цветовая модель} & \textbf{Кр. 1} & \textbf{Кр. 2} & \textbf{Кр. 3} & \textbf{Кр. 4} \\ \hline
        RGB   & аддитивный    & 3 & -- & -- \\ \hline
        RGBA  & аддитивный    & 4 & +  & -- \\ \hline
        CMYK  & субтрактивный & 4 & -- & -- \\ \hline
        LAB   & перцепционный & 3 & -- & +  \\ \hline
        HSB   & перцепционный & 3 & -- & +  \\ \hline
    \end{tabular}
\end{table}

\section{Постановка задачи}

В рамках выполнения научно-исследовательской работы требуется разработать метод сжатия статических изображений без потерь на основе алгоритма Хаффмана. При создании метода необходимо определить:
\begin{itemize}
    \item входные и выходные данные метода сжатия;
    \item способ хранения информации, необходимой для восстановления исходного качества изображений.
\end{itemize}

В разрабатываемом гибридном методе сжатия улучшение будет производиться за счет первичной обработки изображения другим методом сжатия, а именно словарным методом LZW. Формальная постановка задачи в виде IDEF0-диаграммы представлена на рисунке \ref{img:idef0_a0.pdf}.
\imgs{idef0_a0.pdf}{h!}{1.2}{Формальная постановка задачи в нотации IDEF0}

\subsection*{Вывод}

В данном разделе была проведена классификация основных методов сжатия статических изображений по следующим категориям: сжатие с потерями и сжатие без потерь. В каждой из них было проведено сравнение описанных методов по выделенным критериям.

Унарное кодирование может применяться для сжатия изображений в тех случаях, когда значения пикселей имеют ограниченный диапазон и малую вариацию (черно-белые снимки). Алгоритмы RLE и LZW могут быть полезны для изображений с большими областями одного цвета или повторяющихся участков. Арифметическое кодирование следует использовать для изображений с большим количеством текста, например, для отсканированных документов, где вероятностное распределение частоты появления символов может быть использовано в качестве основы для сжатия. Алгоритм Хаффмана подойдет для сжатия стандартных изображений без потерь, также он может использоваться внутри сжимающих форматов изображений, таких как JPEG для оптимизации размера файлов.

JPEG является одним из наиболее широко используемых методов сжатия изображений, и обычно используется для фотографий и непрерывных тональных изображений. Wavelet сжатие было специально разработано для цветных и черно-белых изображений с плавными переходами, из-за чего подходит для обработки рентгеновских снимков и МРТ. Изображения, представляющие природные сцены, такие как пейзажи, горы, облака, водопады, хорошо подходят для фрактального сжатия, поскольку обладают повторяющимися узорами и самоподобием.
