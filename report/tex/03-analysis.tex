\chapter{Аналитическая часть}

\section{Анализ предметной области}

Все изображения можно разделить на две группы.
\begin{enumerate}
    \item \textbf{Статические изображения} --- это визуальные представления, не содержащие анимации или элементов взаимодействия. Они остаются неизменными и могут быть представлены в виде рисунков, фотографий, диаграмм или любых других неподвижных изображений сцен или объектов.
    \item \textbf{Динамические изображения} --- это визуальные представления, содержащие движения или изменения в течение времени. В отличие от статических, они могут быть анимированными, интерактивными (реагировать на клики или наведение) или включать переходы. Примеры: анимация, видео, GIF-файлы, интерактивная графика.
\end{enumerate}

Существуют два основных типа сжатия изображений --- с потерями и без потерь \cite{book-1}. Сжатие без потерь позволяет уменьшить размер файла с сохранением всех деталей исходного изображения. Сжатие с потерями приводит к более сильному уменьшению размера исходного файла ценой потери его деталей, следствием чего является потеря качества изображения.

Разработаны различные форматы файлов изображений, каждый из которых предназначен для определенных задач и использует в своей реализации собственные способы сжатия и сохранения информации. Например, формат JPEG используется для сжатия с потерями, тогда как формат PNG предназначен для сжатия изображений без потерь \cite{book-2}.

Уменьшить размер сжатого файла можно путем изменения параметров сжатия, таких как качество изображения и его разрешение. Более высокие значения этих параметров приведут к увеличению размера получеого файла.

Сокращение числа цветов в изображении также будет способствовать уменьшению размера сжатого файла, так как приведет к снижению числа байт, необходимых для представления каждого пикселя \cite{article-algorithms}.


\section{Методы сжатия статических изображений без потерь}

\subsection{Метод RLE}

Метод RLE \cite{RLE} основан на идее кодирования последовательностей повторяющихся значений. Задача данного метода заключается в нахождении цепочек одинаковых символов и замене их на одно значение из последовательности и количество повторений. Такой алгоритм подходит для сжатия как текстовых файлов, так и изображений, где в роли каждого символа выступает набор байт, необходимый для хранения одного пикселя.

Например, если изображение содержит несколько подряд идущих пикселей одного цвета, то рассматриваемый метод закодирует данную последовательность в виде одного пикселя и количества его повторений. Из описания алгоритма можно сделать вывод о том, что он эффективен для изображений с большим количеством повторяющихся участков или частыми областями одного цвета. Однако RLE не подходит для изображений с большим количеством деталей, где, помимо низкой степени сжатия, может привести к увеличению размера файла.

Рассматриваемый метод относится к сжатию без потерь и может использоваться как отдельно, так и в комбинации с другими алгоритмами для достижения лучшего результата.

Процесс работы алгоритма можно описать следующим образом \cite{article-rle}.
\begin{enumerate}
    \item Создать пустую строку для хранения результата.
    \item Произвести проход по всем пикселям изображения (по всем строкам слева направо).
    \item Для каждого пикселя.
    \begin{itemize}
        \item Если он совпадает с предыдущим:
        \begin{itemize}
            \item увеличить счетчик повторений.
        \end{itemize}
        \item Если отличается или достигнут конец строки:
        \begin{itemize}
            \item в результирующую строку записать значение предыдущего пикселя и количество его повторений;
            \item сбросить счетчик и начать отсчет заново.
        \end{itemize}
    \end{itemize}
    \item После завершения прохода добавить данные о последнем пикселе и количестве его повторений.
    \item Вернуть строку с закодированными данными.
\end{enumerate}

Пример работы алгоритма:
\begin{itemize}
    \item входная строка: \texttt{FFFFCCBBBDAA};
    \item закодированные данные: \texttt{4F2C3B1D2A}.
\end{itemize}

\subsection{Словарные методы}

Словарные методы сжатия, например LZW (Lempel-Ziv-Welch) \cite{LZW}, основаны на использовании специального словаря, в котором повторяющиеся последовательности заменяются более короткими кодами. Такой подход позволяет существенно сократить объем данных за счет замены часто встречающихся шаблонов уникальными кодами из словаря.

Принцип работы алгоритма LZW заключается в том, что он анализирует входные данные и постепенно строит словарь, где каждой повторяющейся последовательности символов присваивается определенный код. После создания словаря эти коды используются для замены изначальных последовательностей, что и обеспечивает сжатие.

Изначально словарь содержит все возможные односимвольные последовательности (пиксель изображения считается за один символ) \cite{article-lzw}. Далее LZW начинает проходить по всем значениям входной строки, формируя текущую последовательность символов. 
Как только сформируется цепочка значений, отсутствующая в словаре:
\begin{itemize}
    \item текущую последовательность добавится в словарь с уникальным кодом;
    \item в выходной поток запишется код уже известной цепочки.
\end{itemize}
Этот процесс продолжается до тех пор, пока весь поток данных не будет обработан. При декодировании используется тот же словарь значений.

Пошаговый алгоритм метода LZW можно описать следующим образом.
\begin{enumerate}
    \item Создать словарь со всеми возможными односимвольными значениями (пикселями).
    \item Установить начальное значение последовательности W равным первому символу входных данных.
    \item Последовательно считывать символа K из входного потока.
    \begin{itemize}
        \item Проверить, содержится ли комбинация W + K в текущем словаре.
        \item Если да:
        \begin{itemize}
            \item присвоить W значение W + K.
        \end{itemize} 
        \item Если нет:
        \begin{itemize}
            \item добавить код для текущей последовательности W в результат;
            \item добавить новую комбинацию W + K в словарь с уникальным кодом;
            \item присвоить W значение K.
        \end{itemize}
    \end{itemize}
    \item Добавить код последней оставшейся в буфере последовательности W.
    \item Вернуть полученный результат в виде последовательности кодов.
\end{enumerate}

\subsection{Унарное кодирование}

Унарное кодирование \cite{UnaryEncoding} представляет собой префиксный код, основанный на идее представления целых положительных чисел $n$ в виде последовательности из $(n - 1)$ битов со значением 1, и одного бита со значением 0, следующим за цепочкой единиц. Также возможно обратное представление, где в начале кода идет последовательность из $(n - 1)$ нулей, заканчивающаяся единицей.

Данный метод следует использовать только для представления очень малых чисел, в противном случае унарное кодирование может привести к увеличению размера исходного файла. Примером эффективного использования является сжатие изображений с малой цветовой палитрой. Например, при сжатии черно-белой фотографии с малым количеством оттенков серого (с 8 оттенками для примера) самый часто встречающийся пиксель получит значение унарного кода \texttt{0} (соответствующее $n = 1$), а самый редко встречающийся будет представлен значением \texttt{11111110} (соответствующим $n = 8$).

Унарное кодирование редко применяется в чистом виде для сжатия изображений, однако используется в качестве одного из этапов более сложных гибридных методов сжатия.

Примеры унарного кодирования:
\begin{itemize}
    \item представление числа 1 (первый вариант) --- \texttt{0};
    \item представление числа 2 (первый вариант) --- \texttt{10};
    \item представление числа 3 (первый вариант) --- \texttt{110};
    \item представление числа 4 (первый вариант) --- \texttt{1110}.
\end{itemize}

\subsection{Метод Хаффмана}

Метод Хаффмана \cite{Huffman} представляет собой метод сжатия данных без потерь, в основе которого лежит замена часто встречающихся символов более короткими кодами, а редко встречающихся --- более длинными. При использовании данного метода для сжатия изображений пиксели будут выступать в роли кодируемых символов.  

При реализации метода Хаффмана необходимо вычислить вес каждого пикселя на основе вероятности вхождения символов в сообщение. Полученная таблица частот будет использоваться при построении дерева Хаффмана.

Алгоритм построения дерева Хаффмана \cite{article-huffman}.
\begin{enumerate}
    \item Создается список узлов из всех уникальных символов сообщения.
    \item Каждому узлу присваивается вес, равный частоте появления символа в сообщении.
    \item Из списка выбираются два узла с наименьшими весами.
    \item Создается новый узел-родитель, объединяющий выбранные два, с весом, равным сумме весов дочерних узлов.
    \item В направлении к потомку с меньшим весом назначается бит 1, с большим весом --- бит 0.
    \item Два потомка удаляются из списка, а на их место ставится новый родительский узел.
    \item Шаги 2--5 повторяются до тех пор, пока в списке не останется один узел --- корень дерева.
\end{enumerate}

Построенное дерево используется для получения кодов символов (пикселей). Для этого нужно выбрать лист дерева Хаффмана, соответствующий текущему значению, и построить путь от него до корня дерева, добавляя биты при каждом переходе от одного узла к другому. Полученная последовательность битов будет представлять собой код данного символа (пикселя), записанный в обратном порядке.

Благодаря уникальным префиксам полученных кодов, каждый символ может быть однозначно декодирован, несмотря на то, что коды Хаффмана имеют переменную длину.

Для восстановления исходного изображения требуется доступ к таблице частот пикселей, по которой можно воссоздать дерево Хаффмана и декодировать сжатые данные. Хранение такой таблицы или структуры дерева приводит к увеличению размера сжатого файла. Также к недостатку рассмотренного метода относится необходимость в дополнительном проходе по изображению:
\begin{itemize}
    \item первый --- для построения дерева Хаффмана;
    \item второй --- для кодирования данных.
\end{itemize}


\subsection{Арифметическое кодирование}

Арифметическое кодирование \cite{ArithmeticCoding} --- это блочный метод сжатия данных, при котором все входное сообщение преобразуется в единый код, уникальный для данной последовательности символов. При таком подходе нельзя разбить код на отдельные части, соответствующие отдельным символам.

В основе метода лежит представление всего сообщения в виде двоичной дроби в диапазоне от 0 до 1. По мере добавления символов интервал, соответствующий текущему сообщению, сужается, требуя все больше битов для точного его описания.

Для работы алгоритма необходимо заранее определить вероятности появления каждого символа. Значения с большей вероятностью появления уменьшают текущий интервал в меньшей степени, в результате чего к окончательному коду добавляется меньше битов. В то время как редкие символы требуют большего уточнения интервала и, следовательно, увеличивают длину кода.

Каждому символу сопоставляется определенный интервал на числовой оси, длина которого соответствует вероятности его появления. Эти интервалы располагаются последовательно один за другим и в сумме образуют диапазон от 0 до 1. При кодировании каждый новый символ <<вырезает>> из текущего интервала подинтервал, соответствующий своей вероятности и положению на оси. В результате конечный интервал однозначно представляет все сообщение.

В отличии от метода Хаффмана, арифметическое кодирование не требует дополнительного прохода по входной строке как при кодировании, так и при восстановлении данных.


\subsection{Сравнение методов сжатия без потерь}

Сравнение предлагается проводить по следующим критериям.
\begin{enumerate}
    \item Возможность кодирования данных за один проход.
    \item Отсутствие необходимости в таблице частот пикселей сжимаемого изображения.
    \item Наличие в зашифрованном сообщении информации для дешифровщика (распаковщика).
    \item Наличие у каждого сжатого пикселя своего кода.
\end{enumerate}

Результаты сравнения методов сжатия изображений без потерь приведены в таблице \ref{tbl:compare_realizations1}.
\begin{table}[H]
    \centering
	\caption{Сравнение рассмотренных методов сжатия изображений без потерь}
    \label{tbl:compare_realizations1}
	\begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Метод сжатия} & \textbf{Кр. 1} & \textbf{Кр. 2} & \textbf{Кр. 3} & \textbf{Кр. 4}
        \\ \hline
        Алгоритм RLE               & +  & +  & -- & -- \\ \hline
        Словарные алгоритмы        & +  & +  & +  & -- \\ \hline
        Унарное кодирование        & +  & -- & +  & +  \\ \hline
        Алгоритм Хаффмана          & -- & -- & +  & +  \\ \hline
        Арифметическое кодирование & +  & -- & +  & -- \\ \hline
    \end{tabular}
\end{table}

\section{Методы сжатия статических изображений с потерями}

\subsection{Метод сжатия JPEG}

JPEG (Joint Photographic Experts Group) \cite{JPEG} --- это метод сжатия изображений с потерями, широко используемый для хранения полноцветных фотографий. Свою популярность JPEG приобрел благодаря способности эффективно уменьшать объем изображений без значительного ухудшения визуального качества. Данный метод работает с блоками пикселей размером $8 \times 8$, яркость и цвет в которых, как правило, изменяются плавно. После разбиения изображения на блоки, каждая полученная матрица раскладывается в двойной ряд по косинусам, что позволяет выделить наиболее значимые коэффициенты. Такой подход позволяет осуществить плавное изменение цветов в изображении, что и приводит к сжатию.

Алгоритм JPEG можно описать следующим образом.
\begin{enumerate}
    \item \textbf{Разделение изображения на блоки} --- исходное изображение делится на небольшие квадратные фрагменты по $8 \times 8$ пикселей.
    \item \textbf{Преобразование цветовой модели} --- преобразование исходной цветовой модели (чаще всего RGB) в YCbCr, где Y обозначает яркость, а Cb и Cr --- цветовые составляющие.
    \item \textbf{Дискретное косинусное преобразование (DCT)} --- применяется к каждому блоку, преобразуя его в набор частотных коэффициентов, отражающих яркостные и цветовые колебания.
    \item \textbf{Квантование} --- полученные коэффициенты округляются с использованием таблицы квантования, в результате чего незначительные детали отбрасываются, что и приводит к потерям.
    \item \textbf{Энтропийное кодирование} --- к оставшимся данным применяется метод энтропийного кодирования, например, алгоритм Хаффмана, где часто встречающиеся значения получают более короткие коды.
    \item \textbf{Формирование файла} --- все закодированные данные объединяются в структуру JPEG-файла, пригодного для хранения и передачи.
    \item \textbf{Декодирование} --- восстановление изображения происходит в обратной последовательности: распаковка, декодирование, обратное квантование, обратное DCT и преобразование в исходную цветовую модель.
\end{enumerate}

Полученное изображение хоть и теряет часть информации, но сохраняет достаточное качество для большинства практических задач.


\subsection{Wavelet сжатие}

Вейвлет-преобразование \cite{WaveletCompression} --- это метод обработки сигналов, позволяющий анализировать их частотные характеристики. В отличие от алгоритмов сжатия, таких как JPEG или фрактальные методы, вейвлеты не требуют предварительного разбиения изображения на блоки, так как могут применяться ко всему изображению целиком, что помогает избежать появления артефактов на границах блоков.

Например, рассмотрим одномерное преобразование Хаара. Оно работает с парами элементов сигнала, вычисляя их полусумму и полуразность. Эти два значения можно использовать для восстановления исходных данных, что делает преобразование обратимым. В результате сигнал разобьется на:
\begin{itemize}
    \item приближенную часть (низкочастотную составляющую), содержащую основную информацию;
    \item уточняющую часть (высокочастотную составляющую), отражающую мелкие детали.
\end{itemize}

Двумерное вейвлет-преобразование Хаара строится на применении одномерного преобразования сначала к строкам матрицы изображения, затем к его столбцам. В итоге получится четыре подматрицы:
\begin{itemize}
    \item одна матрица с пониженным разрешением, представляющая приближенное изображение;
    \item три матрицы, содержащие уточняющие детали по горизонтали, вертикали и диагонали.
\end{itemize}

Сжатие достигается за счет обнуления наименее значимых коэффициентов из уточняющих подматриц, что позволяет существенно уменьшить объем данных при сохранении важных деталей изображения.

Рассмотренный метод хорошо подходит для сжатия изображений с плавными переходами, что может быть полезно для работы с медицинскими снимками.


\subsection{Фрактальный метод}

Фрактальное сжатие изображений \cite{FractalCompression} --- это метод, основанный на использовании фрактальных кодов и принципа самоподобия, заключающегося в том, что отдельные участки изображения могут быть приближенно выражены через другие его части.

Ход работы алгоритма можно описать следующим образом.
\begin{enumerate}
    \item \textbf{Разбиение изображения на фрагменты.} Исходное изображение делится на небольшие блоки пикселей (диапазонные блоки), размер которых может составлять $4 \times 4$ или $8 \times 8$. Каждый из таких блоков впоследствии сравнивается с другими частями изображения для выявления самоподобия.
    \item \textbf{Определение базисных блоков.} Среди множества участков изображения выбираются опорные блоки (фракталы \cite{Fractal}), которые будут использоваться в качестве шаблонов для аппроксимации других квадратов.
    \item \textbf{Поиск наилучших совпадений.} Для каждого участка изображения ищется наиболее похожий базисный блок. Сходство между блоками оценивается с помощью метрик, таких как среднеквадратичное отклонение или евклидово расстояние.
    \item \textbf{Применение преобразований.} Для определения точного соответствия между рассматриваемым фракталом и диапозонным блоком, к первому применяются различные преобразования, такие как поворот, масштабирование и отражение. 
    \item \textbf{Формирование фрактального описания.} Для каждого блока изображения сохраняется информация о подобранном фрактале и параметрах его преобразования. Эти данные составляют сжатое представление изображения --- фрактальный код.
    \item \textbf{Декодирование изображения.} Восстановление блоков изображения происходит путем поочередного применения к базисным фракталам сохраненных преобразований.
\end{enumerate}

Фрактальное сжатие следует использовать для изображений, содержащих множество повторяющихся структур, таких как текстуры, элементы природы и архитектуры. Данный метод обладает высокой вычислительной сложностью, что затрудняет его использование для работы с изображениями большого размера.

Пример изображения с фракталами приведен на рисунке \ref{img:fractal.png}.
\imgs{fractal.png}{h!}{0.25}{Пример изображения с фракталами}

\subsection{Сравнение методов сжатия с потерями}

Сравнение предлагается проводить по следующим критериям.
\begin{enumerate}
    \item Идея, на которой строится алгоритм сжатия.
    \item Тип артефактов, возникающих при больших коэффициентах сжатия.
    \item Необходимость разбиения исходного изображения на блоки.
    \item Необходимость преобразование изображения из цветовой модели RGB в цветовую модель YCbC.
\end{enumerate}

Результаты сравнения методов сжатия изображений без потерь приведены в таблице \ref{tbl:compare_realizations2}.
\begin{table}[H]
    \centering
	\caption{Сравнение рассмотренных методов сжатия изображений без потерь}
    \label{tbl:compare_realizations2}
	\begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Метод сжатия} & \textbf{Кр. 1} & \textbf{Кр. 2} & \textbf{Кр. 3} & \textbf{Кр. 4}
        \\ \hline
        JPEG        & \begin{minipage}[t]{5.5cm}\centering Дискретное косинусное \newline преобразование \end{minipage} & \begin{minipage}[t]{3.1cm}\centering Блочные \newline артефакты \newline \end{minipage} & + & + \\ \hline
        Wavelet     & Вейвлет-преобразование & \begin{minipage}[t]{3.1cm}\centering Кольцевые \newline артефакты \newline \end{minipage}     & -- & --  \\ \hline 
        Фрактальный & Самоподобие множеств   & \begin{minipage}[t]{3.1cm}\centering Артефакты \newline реконструкции \newline \end{minipage} & +  & -- \\ \hline
    \end{tabular}
\end{table}

\section{Цветовые модели изображений}

\subsection{Анализ цветовых моделей изображений}

Цветовые модели изображений представляют собой математические способы представления цветов в таком формате, в котором цифровые устройства могут их интерпретировать и отобразить, выполнить над ними различные манипуляции или перевести из одного формата в другой. Данные модели определяют структуру хранения цветов. Далее представлены основные цветовые модели изображений.

\begin{enumerate}
    \item \textbf{RGB (Red, Green, Blue)} \cite{RGB} --- это аддитивная модель цвета, основанная на смешивании трех основных компонентов: красного, зеленого и синего. Она широко применяется в электронных устройствах, где изображение формируется путем добавления света. Каждый цветовой канал принимает значения от 0 до 255, что дает более 16 миллионов возможных оттенков. RGB считается стандартной моделью для отображения информации на экранах.
    \item \textbf{RGBA (Red, Green, Blue, Alpha)} \cite{RGB} --- это расширенная версия модели RGB, включающая альфа-канал, который задает степень прозрачности. Значение альфа-канала варьируется от 0 (полностью прозрачно) до 255 (полностью непрозрачно). Эта модель особенно полезна в компьютерной графике и анимации, где требуется реализовать эффекты прозрачности и наложения.
    \item \textbf{CMYK (Cyan, Magenta, Yellow, Key/Black)} \cite{CMYK} --- субтрактивная модель, используемая преимущественно в печатных технологиях. Цвета формируются путём вычитания света при наложении цветных чернил на белую поверхность. В отличие от RGB, CMYK использует голубой, пурпурный, жёлтый и чёрный цвета. Такая модель обеспечивает высокую точность цветопередачи при печати и применяется в типографике и издательском деле.
    \item \textbf{LAB (Lightness, A, B)} \cite{Lab} --- модель, описывающая цвет на основе восприятия человеческим глазом. Она состоит из компонента яркости (Lightness) и двух цветовых осей: A (от зелёного к красному) и B (от синего к жёлтому). LAB не зависит от конкретного устройства, что делает её полезной при преобразовании изображений между различными цветовыми пространствами и для точной цветокоррекции. Данная цветовая модель охватывает более широкий спектр цветов, чем RGB или CMYK.
    \item \textbf{HSB (Hue, Saturation, Brightness)} \cite{HSB} --- цветовая модель, описывающая цвет с точки зрения оттенка, насыщенности и яркости. Основной цвет определяется оттенком, насыщенность показывает его чистоту и интенсивность, а яркость отражает степень светлоты. Благодаря своей интуитивности, HSB широко используется в приложениях для работы с цветом, таких как графические и дизайнерские программы.
\end{enumerate}

\subsection{Сравнение цветовых моделей изображений}

Сравнение предлагается проводить по следующим критериям.
\begin{enumerate}
    \item Класс метода по принципу действия.
    \item Количество байт для кодирования одного пикселя.
    \item Наличие поддержки альфа-канала.
    \item Отсутствие отдельного канала для яркости.
\end{enumerate}

Результаты сравнения цветовых моделей изображений приведены в таблице \ref{tbl:color_models}.
\begin{table}[H]
    \centering
	\caption{Сравнение рассмотренных цветовых моделей изображений}
    \label{tbl:color_models}
	\begin{tabular}{|c|c|c|c|c|}
        \hline
        \textbf{Цветовая модель} & \textbf{Кр. 1} & \textbf{Кр. 2} & \textbf{Кр. 3} & \textbf{Кр. 4} \\ \hline
        RGB   & аддитивный    & 3 & -- & +  \\ \hline
        RGBA  & аддитивный    & 4 & +  & +  \\ \hline
        CMYK  & субтрактивный & 4 & -- & +  \\ \hline
        LAB   & перцепционный & 3 & -- & -- \\ \hline
        HSB   & перцепционный & 3 & -- & -- \\ \hline
    \end{tabular}
\end{table}

\section{Постановка задачи}

В рамках выполнения научно-исследовательской работы требуется разработать метод сжатия статических изображений без потерь на основе алгоритма Хаффмана. При создании метода необходимо определить:
\begin{itemize}
    \item входные и выходные данные метода сжатия;
    \item способ хранения информации, необходимой для восстановления исходного качества изображений.
\end{itemize}

В разрабатываемом гибридном методе сжатия улучшение будет производиться за счет первичной обработки изображения другим методом сжатия, а именно словарным методом LZW. Формальная постановка задачи в виде IDEF0-диаграммы представлена на рисунке \ref{img:idef0_a0.pdf}.
\imgs{idef0_a0.pdf}{h!}{0.82}{Формальная постановка задачи в нотации IDEF0}

\subsection*{Вывод}

В данном разделе была проведена классификация основных методов сжатия статических изображений по следующим категориям: сжатие с потерями и сжатие без потерь. В каждой из них было проведено сравнение описанных методов по выделенным критериям. Также были рассмотрены основные цветовые модели изображений.

Унарное кодирование может применяться для сжатия изображений в тех случаях, когда значения пикселей имеют ограниченный диапазон и малую вариацию (черно-белые снимки). Алгоритмы RLE и LZW могут быть полезны для изображений с большими областями одного цвета или повторяющихся участков. Арифметическое кодирование следует использовать для изображений с большим количеством текста, например, для отсканированных документов, где вероятностное распределение частоты появления символов может быть использовано в качестве основы для сжатия. Алгоритм Хаффмана подойдет для сжатия стандартных изображений без потерь, также он может использоваться внутри сжимающих форматов изображений, таких как JPEG для оптимизации размера файлов.

JPEG является одним из наиболее широко используемых методов сжатия изображений, и обычно используется для фотографий и непрерывных тональных изображений. Wavelet сжатие было специально разработано для цветных и черно-белых изображений с плавными переходами, из-за чего подходит для обработки рентгеновских снимков и МРТ. Изображения, представляющие природные сцены, такие как пейзажи, горы, облака, водопады, хорошо подходят для фрактального сжатия, поскольку обладают повторяющимися узорами и самоподобием.
